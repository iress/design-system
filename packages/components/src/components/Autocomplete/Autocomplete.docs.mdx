import { Meta } from '@storybook/addon-docs/blocks';
import {
  ComponentOverview,
  ComponentExample,
} from '@iress-oss/ids-storybook-config';
import * as ComponentStories from './Autocomplete.stories';

<Meta of={ComponentStories} />

# Autocomplete

<ComponentOverview
  description="Autocomplete allow for users to fill in their input by providing suggestions as they type."
  of={ComponentStories.Default}
  meta={ComponentStories}
/>

## Usage

The `IressAutocomplete` element extends `IressInput` with additional functionality to provide suggestions to the user as they type.

There is no validation done between the suggestions and the input value. They are strictly suggestions to improve the user experience. If you would like to restrict the input to the suggestions, you can use `IressCombobox`.

### Uncontrolled

The `defaultValue` prop can be used to set the initial value of the input. The value will be managed by the component.

<ComponentExample of={ComponentStories.Uncontrolled} />

### Controlled

The `value` prop can be used to completely control the state of the component. Use the `onChange` and `onClear` props to sync your state with the component.

<ComponentExample of={ComponentStories.Controlled} />

### Providing suggestions

#### `options`

To use the suggestion functionality, you can provide an array of `LabelValueMeta[]` objects to the `options` prop.

**Note:** If `value` is provided on a suggestion item, it will be used (casted to a string) instead of the `label` key. This is useful when you want to display a different value to the user than what is used for filtering.

<ComponentExample of={ComponentStories.Options} />

#### Asynchronous `options`

If you would like to render suggestions from the server, you can pass a function to the `options` prop. It accepts a string parameter and returns a promise that resolves to an array of `LabelValueMeta[]` objects.

<ComponentExample of={ComponentStories.AsyncOptions} />

#### Minimum search length for async options

When using asynchronous options, you can set a minimum number of characters required before triggering the search using the `minSearchLength` prop. This prevents unnecessary API calls and loading states for very short queries.

By default, async searches are triggered after 1 character. Setting a higher value (e.g., 3) means no search request will be made and no loading spinner will appear until the user types at least that many characters.

<ComponentExample of={ComponentStories.AsyncOptionsMinSearchLength} />

#### `initialOptions`

If you want to provide initial options to the user, you can use the `initialOptions` prop. This is useful when you want to provide a list of options to the user before they start typing (eg. recommended search terms).

<ComponentExample of={ComponentStories.InitialOptions} />

## Behaviour

- As long as there is a single character in the input, the suggestions will be displayed in a popover. Unless `initialOptions` are provided where the popover will be displayed immediately on focus.
- The popover will close when the input is empty, unless `initialOptions` are provided.
- The suggestions will be filtered based on the input value.
- Tapping on a suggestion with the mouse will change the input value to the selection and close the popover.
- When the user presses the arrows keys while the input is focussed, suggestions will be highlighted, but focus remains on the input.
- When the user presses the enter key while a suggestion is highlighted, the suggestion will be selected and the popover will close.
- When the user presses the down key while the popover is closed, it will open the popover.
- When the user pressed the up key while the first suggestion is highlighted, it will close the popover.
- When the user tabs away while no suggestion is highlighted, the input will not be changed.
- When the user tabs away while a suggestion is highlighted, the suggestion will be selected.
- When the user tabs away while the popover is open, the popover will close.

## Accessibility

The autocomplete component follows the [WAI combobox pattern: List autocomplete with manual selection](https://www.w3.org/WAI/ARIA/apg/patterns/combobox/#:~:text=List%20autocomplete%20with%20manual,value%20in%20the%20popup). An example of this pattern outside of IDS can be seen at [WAI-ARIA combobox example](https://www.w3.org/WAI/ARIA/apg/patterns/combobox/examples/combobox-autocomplete-list/).

There is a key difference:

- For better usability, virtual focus is used to highlight the suggestions inside the popover. This means focus remains on the input, but the suggestions are highlighted as if they are in focus, allowing the user to type and navigate the suggestions with the arrow keys.
- To denote the highlighted suggestion to screen readers, the `aria-activedescendant` attribute is used.

## Examples

### `autoSelect`

The `autoSelect` prop will automatically select the highlighted option when the user blurs the autocomplete. This is set to true by default, but can be switched off.

<ComponentExample of={ComponentStories.RemoveAutoSelect} />

### Input props

Autocomplete extends `IressInput`, hence it has the same properties as `IressInput`.

It does have some defaults to help with user experience. `append` automatically has a search icon, and `clearable` is set to true by default.

<ComponentExample of={ComponentStories.InputProps} />

### No results

If you would like to show a message when there are no results, you can use the `noResultsText` prop. It accepts any React node.

<ComponentExample of={ComponentStories.NoResultsText} />

### Popover props

Under the hood, autocomplete uses `IressInputPopover` to display the suggestions. It accepts `autoHighlight`, `align`, `className` and `displayMode`.

There are two additional props that autocomplete accepts to customise the popover: `append` and `prepend`. You can place additional content above or below the results using these props.

<ComponentExample of={ComponentStories.PopoverProps} />

### Debounce threshold

The `debounceThreshold` prop can be used to set the time in milliseconds to wait before making a request to the `options` function. This is useful when you want to prevent making too many requests to the server.

By default there is a debounce, but it can be removed by setting it to `0`.

<ComponentExample of={ComponentStories.DebounceThreshold} />

### Result limits

You can limit the maximum amount of search results displayed in the suggestions by setting the `limitDesktop` prop. This defaults to 12.

On smaller screens (< 768px), the number of options is further reduced by using the `limitMobile` prop, which defaults to 6.

`limitMobile` works by filtering the search results that have been filtered by `limitDesktop`, so must be a smaller value. For example:

```tsx
// 12 results on large screens, 6 on small screens (default values)
<IressAutocomplete options={...} />

// 4 results on large screens, 3 on small screens
<IressAutocomplete resultLimitDesktop={4} resultLimitMobile={3} options={...} />

// 4 results on all screens (resultLimitMobile > resultLimitDesktop so has no effect)
<IressAutocomplete resultLimitDesktop={4} resultLimitMobile={5} options={...} />
```

The result limits will also affect the number of initial options displayed, if the `initialOptions` prop is set.

<ComponentExample of={ComponentStories.ResultLimits} />

### Read only

The `readOnly` prop can be set to `true` to prevent the user from changing the value of the autocomplete. This will change the input to a custom read-only style and the user will not be able to interact with the input.

If you need more control over the read-only state (for example, rendering a stylised version of the value), you can use the [`IressReadonly` component](?path=/docs/components-readonly--docs).

<ComponentExample of={ComponentStories.ReadOnly} />

## Testing

To help you effectively test the autocomplete component, we have provided a few tips based on the behaviour of the component and our own experience.

**Note:** These are suggestions and not requirements. You should test the component in a way that best suits your use case.

### Partial query matching

The suggestions are filtered based on the input value. If the input value only matches a part of the option, the input value is highlighted by a `<b />` tag in each option. You will need to account for this in your tests, either using an exact string match with a space to denote the highlighted value, or using a regex to match the string.

If you are using `meta`, `prepend` or `append` props in `LabelValueMeta`, you should also consider this in your search query for the option.

```tsx
render(
  <IressAutocomplete
    options={[
      { label: 'Luke Skywalker', value: 'Luke Skywalker', meta: 'male' },
    ]}
  />,
);

const autocomplete = screen.getByRole('combobox');
await user.type(autocomplete, 'lu');

// Exact string match with a space to denote the highlighted value
const option = await screen.findByRole('option', {
  name: 'Lu ke Skywalker male',
});
expect(option).toBeInTheDocument();

// Using a regex to match the string
const option = await screen.findByRole('option', { name: /Skywalker/ });
expect(option).toBeInTheDocument();
```

### Query for minimal characters

If you are testing if a specific option appears in the autocomplete that returns asynchronous `options`, it is recommended to use the shortest possible query to return the desired result. The longer the query, the longer it will take to see the results.

```tsx
render(<IressAutocomplete options={searchStarWarsCharacters} />);
const autocomplete = screen.getByRole('combobox');

// DO: Use the shortest query to return the desired result
await user.type(autocomplete, 'lu');
const option = await screen.findAllByRole('option');

// DON'T: Use a long query to return the desired result
await user.type(autocomplete, 'luke skywalker');
const option = await screen.findAllByRole('option');
```

### Use mocking when testing APIs

When testing the autocomplete component with asynchronous `options`, you should mock the API call to return a known set of results, rather than rely on a public prototyping API (eg. https://swapi.py4e.com/). This will allow you to test the component in isolation without relying on the API to return the expected results, as well as reduce chance of flakiness due to timeouts in your tests.

We recommend using [Mock Service Worker](https://mswjs.io/) to mock the API calls in your tests.

```tsx
// src/mocks/handlers.ts
import { http, HttpResponse } from 'msw';

export const handlers = [
  // Intercept "GET https://swapi.py4e.com/api/people" requests...
  http.get('https://swapi.py4e.com/api/people', () => {
    // ...and respond to them using this JSON response.
    return HttpResponse.json([
      { name: 'Luke Skywalker', gender: 'male' },
      { name: 'Leia Skywalker', gender: 'female' },
    ]);
  }),
];

// src/mocks/node.js
import { setupServer } from 'msw/node';
import { handlers } from './handlers';

export const server = setupServer(...handlers);

// src/CustomAutocomplete.test.tsx
import { server } from './mocks/node';

server.listen();

render(<IressAutocomplete options={searchStarWarsCharacters} />);
const autocomplete = screen.getByRole('combobox');

await user.type(autocomplete, 'lu');
const option = await screen.findAllByRole('option');
```
