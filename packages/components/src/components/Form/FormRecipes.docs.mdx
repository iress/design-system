import { Meta } from '@storybook/addon-docs/blocks';
import * as ComponentStories from './FormRecipes.stories';
import { ComponentExample } from '@iress-oss/ids-storybook-config';
import { IressAlert } from '../../main';

<Meta of={ComponentStories} />

# Recipes

## With readonly data

You can use `IressForm` with readonly data by setting the `readonly` prop to `true` on controlled elements. This will disable those form controls, but will include the values in the form submission.

Please take note of the following when displaying read only data.

- It is best to keep readonly data in a separate section of the form, to further avoid confusion with editable fields.

<ComponentExample
  of={ComponentStories.WithReadonlyData}
  meta={ComponentStories}
/>

## Switching between readonly and edit modes

It is recommended to use a button to toggle between read-only and editable input modes.

Please take note of the following when switching between modes:

- Switching is done on a per-section basis, not on a per-field basis.
- When the user saves the data, it should switch back to read-only mode to avoid any confusion about whether the changes have been saved.

<ComponentExample
  of={ComponentStories.SwitchEditReadonly}
  meta={ComponentStories}
/>

## Alternative form validation

`IressForm` is always recommended for all validation, as it is the cleanest way (least code) to provide the best form user experience for your users. Please visit the [`IressForm` documentation](/docs/components-form--docs) for different validation examples.

However, if you have more complex requirements and you find `IressForm` too opinionated for your needs, you can always bring your own form validation using a native `form` element and the other IDS components such as `IressField`.

Here is an example showcasing a form using the native form constraints API to achieve validation using IDS components. There are other libraries such as: [Yup](https://github.com/jquense/yup), [Joi](https://github.com/hapijs/joi) or [Zod](https://zod.dev/)) which can improve scalability, with the downside being you will have to maintain all validation yourself.

<ComponentExample
  of={ComponentStories.NativeValidation}
  meta={ComponentStories}
/>

## Nested forms

Unfortunately, it is [forbidden to nest form elements as per the HTML specifications](https://developer.mozilla.org/en-US/docs/Learn/Forms/How_to_structure_a_web_form).

To achieve a similar effect, you can use multiple `IressForm` components, and trigger validation in multiple ways:

1. You can trigger specific forms using the `form` attribute of `IressButton`. The [`form` attribute](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/button#form) allows you to specify the form ID to submit when the button is clicked, which can be any form on the page, and will take precedence over the parent form of a button.
2. If you need to trigger multiple forms, you can use the [`requestSubmit` method](https://developer.mozilla.org/en-US/docs/Web/API/HTMLFormElement/requestSubmit) on the form element to trigger the validation of multiple forms.
3. If you only want to trigger validation and not trigger submission even if the validation passes, you can use the `ref` attribute of `IressForm` and trigger validation manually using `ref.current?.api.trigger()`, which is based on the [React Hook Form API](https://react-hook-form.com/docs/useform/trigger).

The example here showcases triggering validation using the `form` attribute of `IressButton` and the `requestSubmit` method on the form element.

<ComponentExample of={ComponentStories.NestedForms} meta={ComponentStories} />

## Form Groups

Powered by [React Hook Form](https://react-hook-form.com/docs/usefieldarray)'s `useFieldArray`, this example allows you add/edit/delete multiple children sections within ONE form (not nested form).

<ComponentExample of={ComponentStories.FormGroups} meta={ComponentStories} />

## Hidden inputs

You can use hidden inputs to store data that you do not want to display to the user, but still need to include in the form submission. This is useful for storing metadata or other information that is not editable by the user.

<IressAlert status="warning" heading="Warning">
  This is not a recommended practice, as it can lead to security issues if
  sensitive data is stored in hidden inputs. It is better to use a variable to
  store your data, and include it in the form submission using the `onSubmit`
  handler.
</IressAlert>

<ComponentExample of={ComponentStories.HiddenInputs} meta={ComponentStories} />

## Validation depend on other fields

This example shows how to validate one field based on another field's value.

The budget amount input validates against the selected budget range using the custom `validateBudgetInput` rules.

<ComponentExample
  of={ComponentStories.ValidationDependOnOtherFields}
  meta={ComponentStories}
/>
