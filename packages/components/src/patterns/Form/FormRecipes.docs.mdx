import { Meta } from '@storybook/addon-docs/blocks';
import * as ComponentStories from './FormRecipes.stories';
import { IressAlert } from '../../main';
import { ComponentExample } from '@iress-oss/ids-storybook-config';

<Meta of={ComponentStories} />

# Recipes

## With readonly data

You can use `IressForm` with readonly data by setting the `readOnly` prop to `true` on controlled elements. This will disable those form controls, but will include the values in the form submission.

Please take note of the following when displaying read only data.

- It is best to keep readonly data in a separate section of the form, to further avoid confusion with editable fields.

<ComponentExample of={ComponentStories.WithReadonlyData} />

## Switching between readonly and edit modes

It is recommended to use a button to toggle between read-only and editable input modes.

Please take note of the following when switching between modes:

- Switching is done on a per-section basis, not on a per-field basis.
- When the user saves the data, it should switch back to read-only mode to avoid any confusion about whether the changes have been saved.

<ComponentExample of={ComponentStories.SwitchEditReadonly} />

## Alternative form validation

`IressForm` is always recommended for all validation, as it is the cleanest way (least code) to provide the best form user experience for your users. Please visit the [`IressForm` documentation](/docs/components-form--docs) for different validation examples.

However, if you have more complex requirements and you find `IressForm` too opinionated for your needs, you can always bring your own form validation using a native `form` element and the other IDS components such as `IressField`.

Here is an example showcasing a form using the native form constraints API to achieve validation using IDS components. There are other libraries such as: [Yup](https://github.com/jquense/yup), [Joi](https://github.com/hapijs/joi) or [Zod](https://zod.dev/)) which can improve scalability, with the downside being you will have to maintain all validation yourself.

<ComponentExample of={ComponentStories.NativeValidation} />

## Nested forms

Unfortunately, it is [forbidden to nest form elements as per the HTML specifications](https://developer.mozilla.org/en-US/docs/Learn/Forms/How_to_structure_a_web_form).

To achieve a similar effect, you can use multiple `IressForm` components, and trigger validation in multiple ways:

1. You can trigger specific forms using the `form` attribute of `IressButton`. The [`form` attribute](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/button#form) allows you to specify the form ID to submit when the button is clicked, which can be any form on the page, and will take precedence over the parent form of a button.
2. If you need to trigger multiple forms, you can use the [`requestSubmit` method](https://developer.mozilla.org/en-US/docs/Web/API/HTMLFormElement/requestSubmit) on the form element to trigger the validation of multiple forms.
3. If you only want to trigger validation and not trigger submission even if the validation passes, you can use the `ref` attribute of `IressForm` and trigger validation manually using `ref.current?.api.trigger()`, which is based on the [React Hook Form API](https://react-hook-form.com/docs/useform/trigger).

The example here showcases triggering validation using the `form` attribute of `IressButton` and the `requestSubmit` method on the form element.

<ComponentExample of={ComponentStories.NestedForms} />

## Form Groups

Powered by [React Hook Form](https://react-hook-form.com/docs/usefieldarray)'s `useFieldArray`, this example allows you add/edit/delete multiple children sections within ONE form (not nested form).

<ComponentExample of={ComponentStories.FormGroups} />

## Forms in expanders (lazy loading)

If you are using forms in expanders, or in other scenarios when the loading of the form may be delayed, it is recommended to only load the form when it is required. This will improve performance of your application, and make it more predictable. It may also fix act warnings in tests if you are seeing some appearing due to conditionally loaded `IressForm` elements.

<ComponentExample of={ComponentStories.FormsInExpanders} />

## Conditional fields (useWatch)

When you have fields that are conditionally shown, you can use the `IressForm.useWatch` hook to watch the value of another field and conditionally render the field.

**Notes:**

- You can use the `api.watch` method on the `IressForm`'s ref to watch the value of a field, but it is recommended to use the hook for better performance by isolating re-rendering at the component level.

<ComponentExample of={ComponentStories.UseWatch} />

## Hidden inputs

You can use hidden inputs to store data that you do not want to display to the user, but still need to include in the form submission. This is useful for storing metadata or other information that is not editable by the user.

<IressAlert status="warning" heading="Warning">
  This is not a recommended practice, as it can lead to security issues if
  sensitive data is stored in hidden inputs. It is better to use a variable to
  store your data, and include it in the form submission using the `onSubmit`
  handler.
</IressAlert>

<ComponentExample of={ComponentStories.HiddenInputs} />

## Validation depend on other fields

This example shows how to validate one field based on another field's value.

The budget amount input validates against the selected budget range using the custom `validateBudgetInput` rules.

<ComponentExample of={ComponentStories.ValidationDependOnOtherFields} />

## Custom form field components

You can integrate custom components within `IressFormField` to create enhanced form experiences.

This demo showcases how to embed a custom `TranscriptTextBox` component into `IressFormField` while leveraging its built-in validation rules, error handling, and state management without additional implementation.

**Reminder:** When building custom form components, avoid managing error message state internally. This helps maintain the IressForm as the single source of truth and ensures consistent, predictable UI behavior.

Key features demonstrated:

- **Universal Integration Pattern**: Shows how any custom component can be embedded in IressFormField
- **Built-in Validation**: Leverages IressFormField's validation rules with custom validation logic
- **Multiple Error Messages**: Displays simultaneous validation errors (e.g., wrong file type AND too large)
- **Drag & Drop**: Files can be dragged and dropped directly onto the textarea
- **File Upload Button**: Traditional file selection via button click
- **Visual Feedback**: UI changes during drag operations with border and background updates
- **Form State Management**: Automatically integrates with form context using controlled props
- **File Management**: Display uploaded files with remove functionality using `IressPanel`

<ComponentExample of={ComponentStories.CustomFormFieldComponents} />
