name: Release

on:
  workflow_run:
    workflows: ['CI']
    types: [completed]
    branches:
      - main
      - 5.x

permissions:
  id-token: write
  contents: write

env:
  NODE_VERSION: '22'
  YARN_VERSION: '4.10.3'

jobs:
  packages:
    name: Packages
    if: github.repository_owner == 'iress'
    runs-on:
      group: wealth-actions-runners
    environment: npm-publishing
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Check CI Success
        if: github.event.workflow_run.conclusion != 'success'
        run: |
          echo "‚ùå CI workflow did not succeed. Skipping release."
          exit 1

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          registry-url: 'https://registry.npmjs.org'

      - name: Enable Corepack
        run: corepack enable

      - name: Detect version changes
        id: version-check
        run: |
          echo "Checking for packages that need publishing..."

          # Function to compare semantic versions without external dependencies
          compare_versions() {
            local v1=$1
            local v2=$2
            
            # Remove 'v' prefix if present
            v1=${v1#v}
            v2=${v2#v}
            
            # Split version and prerelease
            IFS='-' read -r v1_core v1_pre <<< "$v1"
            IFS='-' read -r v2_core v2_pre <<< "$v2"
            
            # Split core version into parts
            IFS='.' read -r v1_major v1_minor v1_patch <<< "$v1_core"
            IFS='.' read -r v2_major v2_minor v2_patch <<< "$v2_core"
            
            # Compare major version
            if [ "$v1_major" -gt "$v2_major" ]; then
              echo "greater"
              return
            elif [ "$v1_major" -lt "$v2_major" ]; then
              echo "less"
              return
            fi
            
            # Compare minor version
            if [ "$v1_minor" -gt "$v2_minor" ]; then
              echo "greater"
              return
            elif [ "$v1_minor" -lt "$v2_minor" ]; then
              echo "less"
              return
            fi
            
            # Compare patch version
            if [ "$v1_patch" -gt "$v2_patch" ]; then
              echo "greater"
              return
            elif [ "$v1_patch" -lt "$v2_patch" ]; then
              echo "less"
              return
            fi
            
            # If we're here, core versions are equal
            # Now compare prerelease versions
            if [ -z "$v1_pre" ] && [ -z "$v2_pre" ]; then
              echo "equal"
            elif [ -z "$v1_pre" ]; then
              # v1 is stable, v2 is prerelease - stable > prerelease
              echo "greater"
            elif [ -z "$v2_pre" ]; then
              # v1 is prerelease, v2 is stable - prerelease < stable
              echo "less"
            else
              # Both have prerelease - lexicographic comparison
              if [[ "$v1_pre" > "$v2_pre" ]]; then
                echo "greater"
              elif [[ "$v1_pre" < "$v2_pre" ]]; then
                echo "less"
              else
                echo "equal"
              fi
            fi
          }

          # Get all non-private workspaces using yarn
          PACKAGES_TO_PUBLISH=""

          while IFS= read -r workspace; do
            # Extract package name and location
            PACKAGE_NAME=$(echo "$workspace" | jq -r '.name')
            PKG_LOCATION=$(echo "$workspace" | jq -r '.location')
            PKG_FILE="$PKG_LOCATION/package.json"
            
            # Extract version from package.json
            LOCAL_VERSION=$(jq -r '.version' "$PKG_FILE")
            
            echo "Checking $PACKAGE_NAME (local: v$LOCAL_VERSION)..."
            
            # Check npm registry for the latest published version
            REGISTRY_VERSION=$(npm view "$PACKAGE_NAME" version 2>/dev/null || echo "not-published")
            
            if [ "$REGISTRY_VERSION" = "not-published" ]; then
              echo "  ‚Üí Not yet published to npm registry"
              echo "  ‚Üí Will publish v$LOCAL_VERSION"
              PACKAGES_TO_PUBLISH="$PACKAGES_TO_PUBLISH $PACKAGE_NAME"
            elif [ "$LOCAL_VERSION" != "$REGISTRY_VERSION" ]; then
              echo "  ‚Üí Registry version: v$REGISTRY_VERSION"
              echo "  ‚Üí Local version: v$LOCAL_VERSION"
              
              # Compare versions using bash function
              COMPARISON=$(compare_versions "$LOCAL_VERSION" "$REGISTRY_VERSION")
              
              if [ "$COMPARISON" = "greater" ]; then
                echo "  ‚Üí Local version is newer, will publish"
                PACKAGES_TO_PUBLISH="$PACKAGES_TO_PUBLISH $PACKAGE_NAME"
              else
                echo "  ‚Üí Local version is not newer than registry, skipping"
              fi
            else
              echo "  ‚Üí Already published at v$LOCAL_VERSION, skipping"
            fi
          done < <(yarn workspaces list --no-private --json)

          if [ -n "$PACKAGES_TO_PUBLISH" ]; then
            # Trim leading/trailing whitespace
            PACKAGES_TO_PUBLISH=$(echo "$PACKAGES_TO_PUBLISH" | xargs)
            echo "‚úÖ Packages to publish: $PACKAGES_TO_PUBLISH"
            echo "has_version_changes=true" >> $GITHUB_OUTPUT
            echo "packages_to_publish=$PACKAGES_TO_PUBLISH" >> $GITHUB_OUTPUT
          else
            echo "‚ÑπÔ∏è No packages need publishing. All versions match npm registry."
            echo "has_version_changes=false" >> $GITHUB_OUTPUT
          fi

      - name: Install dependencies
        if: steps.version-check.outputs.has_version_changes == 'true'
        run: yarn install --immutable

      - name: Build packages
        if: steps.version-check.outputs.has_version_changes == 'true'
        run: yarn build

      - name: Publish to NPM
        if: steps.version-check.outputs.has_version_changes == 'true'
        id: publish
        run: |
          PACKAGES="${{ steps.version-check.outputs.packages_to_publish }}"

          echo "Publishing packages: $PACKAGES"

          # Store package info for GitHub releases
          RELEASE_INFO=""

          for PACKAGE in $PACKAGES; do
            echo "Publishing $PACKAGE..."
            
            # Get package.json path
            PKG_PATH=$(yarn workspaces list --json | jq -r "select(.name == \"$PACKAGE\") | .location")
            PKG_FILE="$PKG_PATH/package.json"
            
            # Extract version from package.json
            VERSION=$(jq -r '.version' "$PKG_FILE")
            echo "  Version: $VERSION"
            
            # Determine npm tag based on version
            if [[ "$VERSION" =~ ^[0-9]+\.[0-9]+\.[0-9]+-([a-zA-Z]+) ]]; then
              # Has prerelease identifier (e.g., alpha, beta, rc)
              NPM_TAG="${BASH_REMATCH[1]}"
              IS_PRERELEASE="true"
              echo "  NPM Tag: $NPM_TAG (prerelease)"
            else
              # Stable version
              NPM_TAG="latest"
              IS_PRERELEASE="false"
              echo "  NPM Tag: $NPM_TAG (stable)"
            fi
            
            # Publish with determined tag
            yarn workspace "$PACKAGE" npm publish --tag "$NPM_TAG" --access public --provenance
            echo "  ‚úÖ Published $PACKAGE@$VERSION with tag '$NPM_TAG'"
            
            # Store info for GitHub releases (package,version,prerelease)
            RELEASE_INFO="${RELEASE_INFO}${PACKAGE}|${VERSION}|${IS_PRERELEASE};"
          done

          echo "‚úÖ All packages published successfully"

          # Output release info
          echo "release_info=$RELEASE_INFO" >> $GITHUB_OUTPUT

      - name: Create GitHub Releases
        if: steps.version-check.outputs.has_version_changes == 'true'
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          RELEASE_INFO="${{ steps.publish.outputs.release_info }}"

          echo "Creating GitHub releases and tags..."

          # Split by semicolon to get each package entry
          IFS=';' read -ra RELEASES <<< "$RELEASE_INFO"

          for RELEASE_ENTRY in "${RELEASES[@]}"; do
            if [ -z "$RELEASE_ENTRY" ]; then
              continue
            fi
            
            # Split by pipe to get package, version, and prerelease flag
            IFS='|' read -r PACKAGE VERSION IS_PRERELEASE <<< "$RELEASE_ENTRY"
            
            # Create tag name (e.g., @iress-oss/ids-components@1.2.3)
            TAG_NAME="${PACKAGE}@${VERSION}"
            
            echo "Creating release for $TAG_NAME..."
            
            # Determine prerelease flag
            if [ "$IS_PRERELEASE" = "true" ]; then
              PRERELEASE_FLAG="--prerelease"
              RELEASE_TYPE="Pre-release"
            else
              PRERELEASE_FLAG=""
              RELEASE_TYPE="Release"
            fi
            
            # Find previous tag for this package
            PREV_TAG=$(git tag -l "${PACKAGE}@*" --sort=-version:refname | head -n 1 || echo "")
            
            # Create temporary file for notes with custom header
            NOTES_FILE=$(mktemp)
            {
              echo "**$RELEASE_TYPE** of \`$PACKAGE\` version \`$VERSION\`"
              echo ""
              echo "## Installation"
              echo ""
              echo "\`\`\`bash"
              echo "npm install ${PACKAGE}@${VERSION}"
              echo "\`\`\`"
              echo ""
              echo "üì¶ [View on npm](https://www.npmjs.com/package/${PACKAGE}/v/${VERSION})"
              echo ""
              echo "---"
            } > "$NOTES_FILE"
            
            # Create GitHub release with auto-generated notes
            # The --generate-notes flag uses GitHub's AI-powered release notes generation
            # which analyzes PRs, categorizes changes, and lists contributors
            if [ -n "$PREV_TAG" ]; then
              echo "  Generating AI-powered release notes from $PREV_TAG to HEAD..."
              gh release create "$TAG_NAME" \
                --title "$PACKAGE $VERSION" \
                --notes-file "$NOTES_FILE" \
                --generate-notes \
                --notes-start-tag "$PREV_TAG" \
                $PRERELEASE_FLAG \
                --target ${{ github.sha }}
            else
              echo "  First release - generating notes..."
              gh release create "$TAG_NAME" \
                --title "$PACKAGE $VERSION" \
                --notes-file "$NOTES_FILE" \
                --generate-notes \
                $PRERELEASE_FLAG \
                --target ${{ github.sha }}
            fi
            
            echo "  ‚úÖ Created release and tag: $TAG_NAME"
            
            # Clean up temp file
            rm -f "$NOTES_FILE"
          done

          echo "‚úÖ All GitHub releases created successfully"
